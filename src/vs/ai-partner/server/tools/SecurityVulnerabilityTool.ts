import * as fs from 'fs/promises';
import * as path from 'path';
import * as vscode from 'vscode';

interface SecurityScanParams {
  filePath: string;
}

// Defines common vulnerability patterns using regular expressions.
const VULNERABILITY_PATTERNS = [
  { type: 'Hardcoded API Key', pattern: /(api_key|apikey|api-key|client_secret|access_token)\s*[:=]\s*['"`][a-zA-Z0-9_\-]{20,}['"`]/gi },
  { type: 'Hardcoded AWS Key', pattern: /AKIA[0-9A-Z]{16}/g },
  { type: 'Hardcoded Private Key', pattern: /-----BEGIN (RSA|EC|OPENSSH) PRIVATE KEY-----/g },
  { type: 'Use of eval()', pattern: /eval\s*\(/g },
];

/**
 * @class SecurityVulnerabilityTool
 * A tool for finding common security vulnerabilities using fast, regex-based static analysis.
 */
export class SecurityVulnerabilityTool {
  public getSchema() {
    return {
      type: "function",
      function: {
        name: "SecurityVulnerabilityTool",
        description: "Scans a file for common security vulnerabilities like hardcoded API keys or use of dangerous functions.",
        parameters: {
          type: "object",
          properties: {
            filePath: { type: "string", description: "The relative path to the file to scan." },
          },
          required: ["filePath"],
        },
      },
    };
  }

  public async execute(params: SecurityScanParams): Promise<any[]> {
    console.log('[SecurityVulnerabilityTool] Executing with params:', params);

    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
      throw new Error('No workspace folder is open.');
    }
    const workspaceRoot = workspaceFolders[0].uri.fsPath;
    const absolutePath = path.resolve(workspaceRoot, params.filePath);

    if (!absolutePath.startsWith(workspaceRoot)) {
        throw new Error('File path is outside of the allowed workspace directory.');
    }

    try {
      const content = await fs.readFile(absolutePath, 'utf-8');
      const lines = content.split('\n');
      const findings = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        for (const vulnerability of VULNERABILITY_PATTERNS) {
          if (vulnerability.pattern.test(line)) {
            findings.push({
              type: 'vulnerability',
              line: i + 1,
              description: vulnerability.type,
              code: line.trim(),
            });
          }
        }
      }

      if (findings.length === 0) {
        return [{ type: 'text', text: `No common vulnerabilities found in ${params.filePath}` }];
      }

      return findings;

    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`File not found at path: ${params.filePath}`);
      }
      throw error;
    }
  }
}
