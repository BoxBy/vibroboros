import * as vscode from \'vscode\';\nimport { A2AMessage } from \'../interfaces/A2AMessage\';\nimport { MCPServer } from \'../server/MCPServer\';\nimport { LLMService } from \'../services/LLMService\';\n\ntype ChatMessage = { author: \'user\' | \'agent\', content: any[] };\n// For tracking the multi-turn conversation with the LLM, including tool usage.\ntype LlmMessage = { role: \'system\' | \'user\' | \'assistant\' | \'tool\', content: string | null, tool_calls?: any[], tool_call_id?: string, name?: string };\n\nexport class OrchestratorAgent {\n    private static readonly AGENT_ID = \'OrchestratorAgent\';\n    private static readonly CHAT_HISTORY_KEY = \'aiPartnerChatHistory\';\n\n    private dispatch: (message: A2AMessage<any>) => void;\n    private mcpServer: MCPServer;\n    private webviewPanel: vscode.WebviewPanel | undefined;\n    private state: vscode.Memento;\n    private chatHistory: ChatMessage[] = [];\n    private llmService: LLMService;\n    private llmConversationHistory: LlmMessage[] = [];\n\n    constructor(dispatch: (message: A2AMessage<any>) => void, mcpServer: MCPServer, state: vscode.Memento) {\n        this.dispatch = dispatch;\n        this.mcpServer = mcpServer;\n        this.state = state;\n        this.llmService = new LLMService();\n        this.chatHistory = this.state.get<ChatMessage[]>(OrchestratorAgent.CHAT_HISTORY_KEY, []);\n    }\n\n    public registerWebviewPanel(panel: vscode.WebviewPanel | undefined): void {\n        this.webviewPanel = panel;\n        if (panel) {\n            this.postMessageToUI({ command: \'loadHistory\', payload: this.chatHistory });\n        }\n    }\n\n    public handleUIMessage(message: any): void {\n        if (message.command === \'loadSettings\' || message.command === \'saveSettings\') {\n            this.handleSettingsCommands(message);\n            return;\n        }\n\n        const userText = this.getUserTextFromUIMessage(message);\n        const userMessage: ChatMessage = { author: \'user\', content: [{ type: \'text\', text: userText }] };\n        this.addMessageToHistory(userMessage);\n\n        this.llmConversationHistory = [{ role: \'user\', content: userText }];\n        this.dispatch({ sender: OrchestratorAgent.AGENT_ID, recipient: \'ContextManagementAgent\', timestamp: new Date().toISOString(), type: \'request-context\', payload: { query: userText } });\n    }\n\n    public async handleA2AMessage(message: A2AMessage<any>): Promise<void> {\n        if (message.type === \'response-context\') {\n            const systemPrompt = this.createSystemPrompt(message.payload);\n            this.llmConversationHistory.unshift({ role: \'system\', content: systemPrompt });\n            await this.processLlmResponse(null);\n        } \n    }\n\n    private async processLlmResponse(llmMessage: LlmMessage | null): Promise<void> {\n        if (llmMessage) {\n            this.llmConversationHistory.push(llmMessage);\n        }\n\n        const config = vscode.workspace.getConfiguration(\'aiPartner\');\n        const apiKey = config.get<string>(\'llmApiKey\') || \'\';\n        const endpoint = config.get<string>(\'mcpServerUrl\') || \'https://api.openai.com/v1/chat/completions\';\n        const toolSchemas = this.mcpServer.getToolSchemas();\n\n        const responseMessage = await this.llmService.requestLLMCompletion(this.llmConversationHistory, apiKey, endpoint, toolSchemas);\n        this.llmConversationHistory.push(responseMessage);\n\n        if (responseMessage.tool_calls && responseMessage.tool_calls.length > 0) {\n            const toolResults = await this.executeToolCalls(responseMessage.tool_calls);\n            await this.processLlmResponse({ role: \'tool\', content: null, tool_calls: toolResults });\n        } else if (responseMessage.content) {\n            const finalResponse: ChatMessage = { author: \'agent\', content: [{ type: \'text\', text: responseMessage.content }] };\n            this.addMessageToHistory(finalResponse);\n            this.postMessageToUI({ command: \'response\', payload: finalResponse });\n        }\n    }\n\n    private async executeToolCalls(toolCalls: any[]): Promise<any[]> {\n        const toolResponses = [];\n        for (const toolCall of toolCalls) {\n            const toolName = toolCall.function.name;\n            const toolArgs = JSON.parse(toolCall.function.arguments);\n            const toolContent = await this.sendMCPRequest(toolName, toolArgs);\n            const contentString = toolContent.map((c: any) => c.text).join(\'\\n\');\n\n            toolResponses.push({\n                tool_call_id: toolCall.id,\n                role: \'tool\',\n                name: toolName,\n                content: contentString,\n            });\n        }\n        return toolResponses;\n    }\n\n    private async sendMCPRequest(tool: string, params: Record<string, any>): Promise<any[]> {\n        const request = { jsonrpc: \'2.0\', id: crypto.randomUUID(), method: \'tools/call\', params: { name: tool, arguments: params } };\n        const response = await this.mcpServer.handleRequest(request);\n        return response.result?.content || [{ type: \'text\', text: `Error: ${response.error?.message}` }];\n    }\n\n    private handleSettingsCommands(message: any): void {\n        if (message.command === \'loadSettings\') {\n            const config = vscode.workspace.getConfiguration(\'aiPartner\');\n            this.postMessageToUI({ command: \'loadSettingsResponse\', payload: { mcpServerUrl: config.get(\'mcpServerUrl\'), llmApiKey: config.get(\'llmApiKey\') } });\n        } else if (message.command === \'saveSettings\') {\n            const config = vscode.workspace.getConfiguration(\'aiPartner\');\n            config.update(\'mcpServerUrl\', message.payload.mcpServerUrl, vscode.ConfigurationTarget.Global);\n            config.update(\'llmApiKey\', message.payload.llmApiKey, vscode.ConfigurationTarget.Global);\n        }\n    }\n\n    private createSystemPrompt(context: any): string {\n        return `You are an expert AI programming assistant integrated into VSCode. Your goal is to help the user with their development tasks. You have access to a set of tools, including tools to read and write files in the user\'s workspace.\n\n**Workflow:**\n1.  **Analyze the Request:** Understand the user's request based on their message and the provided workspace context.\n2.  **Formulate a Plan:** Think step-by-step. If the request requires information from a file, use the \`FileReadTool\`. If it requires creating or modifying code, plan to use the \`FileWriteTool\`.\n3.  **Execute Tools:** Call one tool at a time. After you get the result from a tool, decide on the next step.\n4.  **Respond:** Once you have all the information you need, provide a comprehensive final answer to the user.\n\n**Workspace Context:**\n- Active File: ${context.activeFilePath}\n- Language: ${context.language}\n- Open Files: ${context.openFiles.join(\', \')}\n- Code Preview of Active File:\n---\n${context.contentPreview}\n---\nNow, proceed with the user's request.`;\n    }\n\n    private getUserTextFromUIMessage(message: any): string {\n        return message.query || message.commandString || \'Perform Action\';\n    }\n\n    private addMessageToHistory(message: ChatMessage): void {\n        this.chatHistory.push(message);\n        this.state.update(OrchestratorAgent.CHAT_HISTORY_KEY, this.chatHistory);\n    }\n\n    private postMessageToUI(message: any): void {\n        if (this.webviewPanel) {\n            this.webviewPanel.webview.postMessage(message);\n        }\n    }\n}\n